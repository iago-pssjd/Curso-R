---
title: "Intruducción a R"
author: "Laia Egea e Iago Giné"
date: "10-12/12/2019"
abstract: "El objetivo de este curso es introducir el software R a todas las personas que trabajen con datos y darles las herramientas para el manejo y visualización de datos, así como para algunos análisis estadísticos básicos."
output: 
  html_notebook:
    toc: yes

---

# Presentación del entorno R y Rstudio

* [R](https://www.r-project.org/) y [RStudio](https://rstudio.com/) son dos programas diferentes. 
    + R es el programa que calcula. Es software libre y gratuito, inicialmente enfocado a la computación estadística.
    + R también es el lenguaje en el que escribimos los comandos, pues es también el lenguaje de programación.
    + Hoy en día está ampliamente extendido y entre los lenguajes de programación más utilizados. Como consecuencia:
        * existen muchos foros en internet donde los usuarios plantean/resuelven sus dudas y/o propuestas.
        * hay muchas librerías para R en continuo desarrollo y que permiten usarlo de una manera mucho más rápida y eficiente.
    + RStudio es la interfaz donde estaremos trabajando, pues nos ofrece algunas comodidades.
        * Nos permite crear scripts de una manera más ágil y en un entorno mucho más agradable que usando R.
        * También hace más sencillo instalar y desinstalar librerías, cargar y visualizar bases de datos, etc.
        * Ofrece otras posibilidades más allá de R como crear páginas web, pdf's o archivos word con R integrado, que va más allá de este curso.

* Entre las consecuencias de lo ampliamente usado de R está que podemos encontrar en internet muchos tutoriales introductorios en cualquier idioma:
    * [http://rosuda.org/mitarbeiter/pilhoefer/rkurs2.pdf]
    * [http://b2slab.upc.edu/software-and-tutorials/r-nutshell/]
    * [https://www.cyclismo.org/tutorial/R/index.html]
    * [https://www.uv.es/vcoll/preliminares.html]
    * [http://people.math.aau.dk/~sorenh/misc/rdocs/Rintro-notes.pdf]
    * en la pestaña Resources de la web de [RStudio](https://rstudio.com/)
    * [otros](https://github.com/iago-pssjd/Curso-R/archive/v1.0.zip)

* ... y foros:
    + principalmente [https://stackoverflow.com/questions/tagged/r]
    + para cuestiones relacionadas con RStudio, pero también con las librerías de la familia tidyverse y otros: [https://community.rstudio.com/]

* ... y blogs:
    + principalmente: [https://www.r-bloggers.com/]
    + [https://statisticsglobe.com/r-programming-language/]
    + enfocados a la estadística, pero no sólo (de hecho, diría que los siguientes son los mejores): 
        * [http://www.sthda.com/english/]
        * [http://www.flutterbys.com.au/stats/course.html]
        * [http://www.r-tutor.com/](http://www.r-tutor.com/sitemap)
    + enfocado a la investigación en psicología:
        * [http://personality-project.org/r/](http://personality-project.org/r/)
    + centrado en RStudio: [https://support.rstudio.com/hc/en-us]
    + [https://www.statmethods.net/index.html]
    + [https://www.datacamp.com/community/tags/r-programming]
    
* ... y sobre librerías o materias específicas:
    + sobre librerías en general:
        * [https://rdrr.io/]
        * [https://www.maths.lancs.ac.uk/~rowlings/R/TaskViews/]
    + gráficas en general:
        * [https://www.r-graph-gallery.com/]
    + formas de mostrar descriptivos:
        * [https://dabblingwithdata.wordpress.com/2018/01/02/my-favourite-r-package-for-summarising-data/]


* ... e incluso multitud de libros que podéis encontrar en [https://bookdown.org/]

* ... además de diversos cursos online (MOOC's) en plataformas como Coursera, edX, etc.

* En los enlaces citados se encuentran recursos para utilizar las diferentes librerías, y también para usar R enfocado a las más diversas tareas, desde los cálculos estadísticos más habituales, pero, por ejemplo, también para hacer [meta-análisis](https://bookdown.org/MathiasHarrer/Doing_Meta_Analysis_in_R/), [análisis factorial](https://www.statmethods.net/advstats/factor.html), [estadística bayesiana o machine learning](http://www.r-tutor.com/), etc.

* También tenemos las páginas webs principales en torno a R, que también contienen información útil, pero son más técnicas:
    + [R](https://www.r-project.org/), [CRAN](https://cran.r-project.org/)
    + las publicaciones del projecto: [R News](https://www.r-project.org/doc/Rnews/index.html) (2001 - 2008) y [R Journal](https://journal.r-project.org/archive/) (2009 - presente)
    + [R Forge](https://r-forge.r-project.org/)
    + [https://stat.ethz.ch/R-manual/]

* Entonces, este curso, para qué?

* Y por qué R?
    + Porque puedes guardar las instrucciones que ejecutas en R scripts, y ejecutarlas todas de una vez, sin tener que memorizar y repetir cada uno de los pasos.
    + Porque en internet podrás encontrar solución a (casi) todos los problemas que tengas.
    + Porque podrás personalizar/modificar cada instrucción con las opciones que desees.
    + Porque es gratuito, como la versión de código abierto de RStudio, y los puedes instalar donde desees.
    + Porque si hay varias respuestas a una misma pregunta, lo que al principio puede hacerte dudar sobre cuál escoger, probablemente hay una que te funcionará y te irá mejor que las otras.

# Nociones elementales y funciones básicas

* R es esencialmente una consola en la que el cursor se sitúa tras el símbolo `>`. Ahí se escriben las instrucciones. Se ejecutan con `Enter`.
* Los resultados suelen aparecer debajo. En el caso de gráficas, depende del entorno en que se trabaje (R, RStudio, R Commander, etc.)

**Cómo guardar bien la sintaxis**

* Las instrucciones se pueden escribir todas en un fichero de texto con la extensión `.r` (el R-script), el cual puede ser cargado y ejecutado desde R. En RStudio, lo podemos ver y ejecutar al mismo tiempo en un panel situado junto al panel de la consola.
    + Desde el R-script en RStudio se ejecutan con `Control+Enter`
    + Sin embargo, RStudio no es imprescindible: para abrir, editar y guardar un R-script, una aplicación básica como el `Bloc de notas` de Windows es suficiente.

* Se pueden escribir comentarios (secciones de código que el programa no ejecuta), situando antes un símbolo `#`
* R es un lenguaje orientado a objetos. Para asignar nombre a los objetos usamos el símbolo `<-`
* Los objetos elementales básicos pueden ser de las siquientes clases:
    + Lógicos (`TRUE` y `FALSE`)
    + Numéricos
    + Caracteres


```{r, echo=TRUE}

# línea de código de R que no hace nada

nombre <- "Luis"
nombre # para ver el contenido de un objeto, basta escribir su nombre
varon <- TRUE
edad <- 23; edad # se pueden introducir diferentes instrucciones en una misma línea separadas por ; (indiferentemente de los espacios en blanco en medio)
estatura <- 1.77

```
  
* A partir de los anteriores se pueden crear objetos compuestos con diferentes estructuras, como pueden ser: 
    + Vectores
    + Factores
    + Matrices
    + Data frames: `data.frame(...)`
    + Listas: `list(...)` 
    + Funciones: `function(...){...}`

* Para saber más, [Understanding basic data types in R](https://www.diegobarneche.com/2014-12-11-ufsc/lessons/01-intro_r/data-structures.html)

## Objetos

### Vectores

* Todos los elementos del vector han de ser del mismo tipo:
* Se crean y se unen con la función `c(...)`
* vector[i] para acceder al i-ésimo elemento del vector

```{r, echo=TRUE}

nombre <- c("Luis","Maria")
edad <- c(23,24)
varon <- c(TRUE,FALSE)
estatura <- c(1.77, 1.64) # entre los objetos y las comas puede haber espacios

estatura[2]
```

### Factores

* Los factores pueden ser de dos tipos al igual que las variables categóricas: 
    + Nominales: No ordenados 
    + Ordinales: Ordenados
* Se crean a partir de un vector numérico con las funciones: 
    + Nominales: `as.factor()`
    + Ordinales: `as.ordered` 
* Se crean a partir de un vector de caracteres utilizando `factor()`
* Las etiquetas se asignan con `levels()`

```{r, echo=TRUE}

f <- as.factor(c(1,2,3,1,2,1,1,3,2)) #Factor Nominal
f
levels(f) <- c("Bajo","Medio","Alto")
ford <- as.ordered(f) #Factor Ordinal
ford

```

### Matrices

* Las matrices son una ampliación de los vectores con dos dimensiones: filas y columnas
* Todos los elementos deben ser del mismo tipo
* Se crean con la función `matrix()`
* Para seleccionar un elemento de un matriz: Matriz[i,j]
* Para saber las dimensiones: `dim()`


```{r, echo=TRUE}

ejema <- matrix(c(1,2,3,4,5,6,7,8,9,10,11,12), ncol=3, byrow=TRUE)
ejema

dim(ejema)

ejema[1,1]

```

### Data frames

**¿Cómo deben estar organizadas las filas/columnas en bases de datos longitudinales para leerlas con R?**

* Es la clase de objeto que R asigna a bases de datos. Las filas son individuos o casos y las columnas variables.
* Se crean con la función `data.frame()`
* Cada columna tiene que tener los elementos del mismo tipo.
* Para seleccionar una variable: `NombreDataFrame$NombreVariable`, o lo que es lo mismo `NombreDataFrame[["NombreVariable"]]`
* Para saber la dimensión: `dim()`
* La clase propiamente dicha de un data frame en R es `data.frame`(el resultado de aplicar la función `class`). Sin embargo, la mayoría de librerías que veremos después trabajan con un data frame expandido llamado `tibble` (en este caso el resultado de la función `class` es un vector de 3 componentes, `tbl_df`, `tbl` y `data.frame`).
    + Un `data.frame` podrá ser transformado en `tibble` por medio de la función `as_tibble`, y recíprocamente tenemos la función `as.data.frame`.

```{r, echo=TRUE}

BD <- data.frame(nombre = c("Luis","Maria","Juan"), edad = c(23,24,25), varon = c(TRUE,FALSE, TRUE), estatura = c(1.77,1.64,1.70))
BD

dim(BD)
class(BD)

BD$nombre

BD[1,2]
BD[1,]
BD[,2]

```



### Listas

* Una lista es un objeto consistente en una colección ordenada de objetos que se suelen llamar componentes.
* No es necesario que los componentes sean del mismo tipo, ni de la misma longitud: una lista puede estar compuesta de, por ejemplo, un vector numérico de tamaño 2, un valor lógico, un vector de tamaño 3, una matriz y una función.
* Se construyen con la función `list()`
* La selección de elementos se hace con doble corchete.
* El corchete simple se utiliza para seleccionar una sublista.


```{r, echo=TRUE}
ejemplolista <- list(nombre="Pedro", casado=T,esposa="Maria", no.hijos=3, edad.hijos=c(4,7,9))
ejemplolista

ejemplolista[[5]]

ejemplolista[[5]][2]
```

## Funciones

```{r, echo=TRUE}

x <- 4
class(x) # clase de un objeto
attributes(x) # sus atributos; en este caso no tiene
str(x) # estructura de un objeto; sus características y sus datos
is.character(4) # podemos comprobar si un objeto es de una determinada clase
as.character(4) # un objeto numérico se puede coercionar a un carácter
as.numeric("a") # al revés, no
as.numeric(FALSE) # un objeto lógico se puede coercionar a uno numérico
as.numeric(TRUE)

# las cadenas de caracteres se pueden pegar
paste("a", x) # con un espacio por defecto que se puede cambiar con la opción sep
paste("a", x, sep = ";")
paste0("a", x, "b", 3) # sin separación por defecto


# todo lo anterior es igual para un vector
y <- c(2:4)
y
class(y)
length(x); length(y) # las longitudes
paste0(y,y+3)

table(BD$edad,BD$varon)

```




* Otras funciones prácticas:

```{r, echo=TRUE}

getwd() # el directorio donde R está trabajando
# setwd("C:/...") # para cambiarlo

list.files() # archivos en el directorio donde R está trabajando

ls() # objetos cargados en el entorno de R (los objetos de R con los que podemos trabajar en este momento)
rm(x, ejemplolista) # para eliminar objetos del entorno
ls()



install.packages("magrittr") # para instalar librerías (en este caso, la librería magrittr)
library(magrittr) # para cargar librerías
(.packages()) # para ver qué librerías tenemos cargadas en este momento

# para buscar ayuda sobre una función
help(print) # o bien
?cat



xlist <- list(a = 1:10, logic = c(TRUE,FALSE,FALSE,TRUE), b = c(1,0,0,1)); xlist

lapply(xlist, quantile, probs = 1:3/4)
sapply(xlist, quantile, probs = 1:3/4)

x <- cbind(x1 = 3, x2 = c(4:1, 2:5)) # columnas enlazadas
x; dimnames(x)
dimnames(x)[[1]] <- letters[1:8]; x

apply(x, 2, sum)
apply(x, 1, sum)
mapply(paste, 1:4, 4:1)


```

**Cómo guardar bien los resultados**

* Los objetos de R se pueden guardar en ficheros con la función `save`. 
* Los ficheros se guardan por convención con la extensión `.rda` o `.rdata` (aunque a veces también se escribe la `r` e incluso la `d` en mayúscula, por ejemplo `.RData`)
* Los resultados, si son matrices, data frames o tablas, además, también se pueden guardar en ficheros `.csv` o con formatos de excel (veremos después algún ejemplo).
* En cualquier caso, en general pueden ser guardados en un fichero de texto con la función `sink`.
* A no ser que se especifique la dirección del fichero, serán guardados en el directorio donde R está trabajando (`getwd()`)

```{r, echo=TRUE}

save(x, y, file = "example.rda")
rm(x)

test_table <- table(BD$edad,BD$varon)

sink("output.log") # se crea el fichero donde se quieren guardar los resultados
# si el fichero ya existe con resultados anteriores que no se quieren borrar, se tiene que poner sink("output.log", append = TRUE)
test_table
cor.test(BD$edad,BD$estatura)
sink()
```

* Recíprocamente, para cargar ficheros de datos de R, tenemos las funciones `load` y `attach`. Debido a la complejidad de esta última, sólo explicamos la primera

```{r, echo=TRUE}

load(file = "example.rda") # carga los objetos guardados con el mismo nombre con el que fueron guardados; sobreescribe los objetos cargados con el mismo nombre

```

* Antes explicamos que la sintaxis de R se guarda en un archivo de texto con la extensión `.r`, que se puede ejecutar fácilmente desde RStudio, o que se puede cargar también desde R. Otra manera de ejecutarlo es a través de la función `source`. Por ejemplo `source("fichero.r)`.


## Operadores aritméticos y lógicos

```{r, echo=TRUE}

x <- 4
2+3
x+5
y <- x-3*7 + 24 # los espacios aquí no afectan

y
y^x # potencia

y %% x # residuo

# floor()
# log(), log10(), log2()
# exp()
# sqrt()
# factorial()

3 == 4
3 == 3
3 < 3
3 <= 3

TRUE & TRUE
TRUE & FALSE
FALSE | FALSE
FALSE | TRUE

nchar(paste(x, 4)) == 3 # el número de caracteres de la cadena "x 4" es 3

length(c(1:3,7,10)) > 6

```


# Funciones y librerías para interaccionar con otros softwares estadísticos como SPSS o STATA

**.csv**

```{r, echo=TRUE}

?read.csv
md_data <- read.csv("MissingData.csv")
str(md_data)

# Para guardar una matriz o data frame en un fichero csv podemos usar write.csv
write.csv(test_table, file = "foo.csv")

```

**Excel**

* Hay muchas librerías que nos permiten trabajar con ficheros de excel, entre ellas `readxl` y `openxlsx`

```{r, echo=TRUE}

library(readxl)
df <- read_excel("example_sheets2.xlsx")
head(df)
str(df)
df <- as.data.frame(df)

library(openxlsx)
df <- read.xlsx("readTest.xlsx",sheet = 1, skipEmptyRows = FALSE); df
df <- read.xlsx("readTest.xlsx",sheet = 3, skipEmptyRows = TRUE); str(df)
df$Date <- convertToDate(df$Date)
str(df)
df2 <- read.xlsx("readTest.xlsx", sheet = 3, skipEmptyRows = TRUE, detectDates = TRUE)
str(df2)

wb <- loadWorkbook("readTest.xlsx") # útil para trabajar con un fichero de excel y escribir en él junto a funciones como writeData y saveWorkbook
df3 <- read.xlsx(wb, sheet = 2, skipEmptyRows = FALSE, colNames = TRUE)
str(df3)
df4 <- read.xlsx("readTest.xlsx", sheet = 2, skipEmptyRows = FALSE, colNames = TRUE)
identical(df3,df4)

```

**¿Se puede abrir un fichero en dta (stata) en R y cambiar su versión, por ejemplo de la 15 a la 13?**

* La librería [haven](https://haven.tidyverse.org/) nos lo permite (entre las versiones 8 y 15).
* Otras librerías que pueden ayudar son: `foreign` y `readstata13`
* Para saber más, [Datasets basics](https://people.umass.edu/biep640w/pdf/R%20handout%202018%20Dataset%20Basics.pdf)

```{r, echo=TRUE}

library(haven)
dta_data <- read_dta("carsdata.dta") # con un archivo de stata 10
dta_data
str(dta_data)

# file from https://digitalcommons.usu.edu/all_datasets/27/
dta_data2 <- foreign::read.dta("Jakus_NCDA.dta") # con un archivo de stata 15
dta_data2 <- read_dta("Jakus_NCDA.dta")
str(dta_data2)
write_dta(dta_data2, "Jakus_NCDA2.dta", version = 12)
dta_data2 <- foreign::read.dta("Jakus_NCDA2.dta")

dta_data3 <- read_dta("gss_sample.dta")
dim(dta_data3)
table(is.na(dta_data3$prestg10)) # cuántos valores missing hay?
table(na_tag(dta_data3$prestg10), useNA = "ifany") # cuántos hay de cada categoría?

# Se pueden guardar datos en un fichero dta con la función write_dta
?write_dta

```

También con la librería `haven`:

**SPSS - .sav**

```{r, echo=TRUE}

sav_data <- read_sav("survey.sav")
dim(sav_data)
str(sav_data[,1:10])

# Se pueden guardar datos en un fichero sav con la función write_sav
?write_sav


```


**SAS**

```{r, echo=TRUE}

sas_data <- read_sas(data_file = "nyts2017.sas7bdat", catalog_file = "formats.sas7bcat")
head(sas_data[, 1:5])
names(sas_data)

sapply(sas_data,class)
sapply(sas_data,mode)

# Se pueden guardar datos en un fichero sav con la función write_sas
?write_sas

```

**Neuroimagen - .nii**

* Para saber más:
    + [https://www.alexejgossmann.com/MRI_viz/]
    + [https://johnmuschelli.com/]

```{r, echo=TRUE}

library(oro.nifti)
library(neurobase)
t1 = readnii("Template-T1-U8-RALPFH-BR.nii.gz")
class(t1)
dim(t1)
t1
image(t1, z = 225, plot.type = "single")
# image(t1) # tarda algo de tiempo en ejecutarse
orthographic(t1)
ortho2(t1)

```


# Manejo de datos con las librerías dplyr & tidyr 

**Prólogo: la librería `magrittr` y 3 pipas. Una gramática diferente**

* Para saber más, [https://www.datacamp.com/community/tutorials/pipe-r-tutorial]

```{r, echo=TRUE}

head(names(sav_data))

sav_data %>% # la pipa más habitual: envía los datos de la izquierda a la función que sigue (a la derecha o abajo) y retorna su evaluación
  names() %>% # está incluida en la librería dplyr
  head()

sav_data %T>% # como la anterior, pero retorna de nuevo los datos de la izquierda
  View() %>% # sirve para usar los datos en más de una función, cuando las intermedias no retornan nada, como View, plot, ...
  names() %>%
  head()

sav_data %$% # para funciones sin un argumento para data.frame's
  cor.test(age,educ)

sas_data %$%
  table(Q2, Q3)

```

* **Ojo**: en ocasiones no conviene usar la pipa: por ejemplo, es mejor `save(data, file)` que `data %>% save(file)`, ya que la segunda opción da lugar a comportamientos inesperados.

**Merge de data frames**

```{r, echo=TRUE}

library(dplyr)

iris %>%
  head()
mtcars %>%
  head()

```

## Selección y filtro de variables 

```{r, echo=TRUE}

select(iris, starts_with("Petal"))

iris %>% select(ends_with("Width"))

iris %>% 
  select(-contains("Length"))

iris %>%
  pull(Species) %>%
  table()

iris %>%
  pull(Species) %>%
  class()

mtcars %>%
  select(drat:qsec)

mtcars %>%
  select(-drat:-qsec)

mtcars %>%
  select(-c(2,8:9))

iris %>%
  filter(Species == "setosa")


```



## Transformación de variables 

**Mutate**

```{r, echo=TRUE}

?mutate_all

sas_data %>%
  select(Q1:Q4C) %>%
  mutate_all(zap_empty) %>% # transforma todas las celdas "" en NA's
  mutate(QAN = paste(Q1,Q3)) %>%
  head()

```



**Pivotaje**

```{r, echo=TRUE}

library(tidyr)
data("anscombe")
anscombe

# 1) pasar de forma ancha a larga las x's

anscombe %>%
  pivot_longer(cols = c(starts_with("x")),
               names_to = "x_cases",
               values_to = "x") %T>%
  View() %>%
  str()

# 1.1) además, renombrar la columna resultante

anscombe %>%
  pivot_longer(cols = c(starts_with("x")),
               names_to = "x_cases",
               names_prefix = "x",
               values_to = "x") %T>%
  View() %>%
  str()

# 2) pasar de forma ancha a larga las x's y las y's

anscombe2 <- anscombe %>%
  # tibble::rownames_to_column('rn') %>%
  pivot_longer(cols = c(starts_with("x"),starts_with("y")),
               names_to = c(".value", "id_cases"),
               names_pattern = "([a-z]+)([0-9]+)") %T>%
  View() %>%
  str()

anscombe2

```



## Estadísticos descriptivos 

Datos que usaremos: 

```{r, echo=TRUE}
head(iris)
?iris

library(dplyr)
data("starwars")
?starwars
head(starwars)
View(starwars)
```


* Listado de estadísticos descriptivos más habituales:

```{r, echo=TRUE}
mean(iris$Sepal.Length) # Media
sd(iris$Sepal.Length) # Desviación típica
var(iris$Sepal.Length) # Varianza
median(iris$Sepal.Length) # Mediana
min(iris$Sepal.Length) # Mínimo
max(iris$Sepal.Length) # Máximo
range(iris$Sepal.Length) # Rango
quantile(iris$Sepal.Length, probs = c(0.025, 0.975)) # Cuantiles
```

* La función `summary()` obtenemos un resumen descriptivo de una variable o bien de todas las variables de un data.frame:

```{r, echo=TRUE}
summary(iris$Sepal.Length) 
summary(iris)
```

* Para variables categóricas:

```{r, echo=TRUE}
table(iris$Species)
```

* Cuando la base de datos tiene missings: 

```{r}
mean(starwars$heigth) 
sd(starwars$heigth)

dim(starwars)
table(starwars$gender)
```


* Para arreglarlo hay que añadir `na.rm = TRUE` per funcions d'estadística descriptiva o useNA = 'always' o 'ifany'. 

```{r}
mean(starwars$heigth, na.rm = TRUE) 
sd(starwars$heigth, na.rm = TRUE) 

table(starwars$gender, useNA = 'always')
table(starwars$genders, useNA = 'ifany')
```

```{r}
table(starwars$hair_color, starwars$eye_color)
```



# Gráficos con la librería ggplot2

* `ggplot2` es una libreria que permite hacer gran variedad de gràficos "bonitos" de manera sencilla. 
* Todos los gràficos de `ggplot2` se podrían hacer también con R básico pero es más complejo. Por otro lado, ggplot2 es un poco más robusto que R básico, es decir, no te permite modificar tantas cosas dado que ya viene predeterminado.
* Las funciones que se utilizan: 
    + `ggplot()`: Crea un gràfico nuevo
    + `aes()`: Para especificar como y que variables intervendrán en todo el gràfico
    + `+`: Para añadir capas

### Gráfico de puntos

```{r}
library(ggplot2)

ggplot(SW, aes(x = mass, y = height)) + 
  geom_point()

ggplot(SW, aes(x = mass, y = height, colour = "red")) + 
  geom_point()

ggplot(SW, aes(x = mass, y = height, colour = gender)) + 
  geom_point()

ggplot(SW, aes(x = mass, y = height, colour = gender, size=birth_year, alpha = 0.5)) + 
  geom_point(shape=23)

ggplot(SW, aes(x = mass, y = height, colour = gender, fill = gender, size=birth_year, alpha = 0.5)) + 
  geom_point(shape=23)
```


# Tests estadísticos y modelos de regresión habituales para el análisis estadístico

## Tests de hipótesis

#### Prueba t de Student

* Prueba paramétrica que compara medias de dos variables (supone que son normales). 

```{r}
summary(iris)

?t.test
t.test(iris$Sepal.Length, iris$Sepal.Width, alternative = "two.sided")
t.test(iris$Sepal.Length, iris$Sepal.Width, alternative = "less")
t.test(iris$Sepal.Length, iris$Sepal.Width, alternative = "greater")

t.test(iris$Sepal.Length, iris$Sepal.Width, alternative = "two.sided", mu = 2.8)
```

#### Prueba Wilcoxon-Mann-Whitney

* Prueba no paramétrica que compara medias de dos variables

```{r}
wilcox.test(x = iris$Sepal.Length, y = iris$Sepal.Width, alternative = "two.sided", mu = 0,
            paired = FALSE, conf.int = 0.95)
```

#### Prueba de Shapiro-Wilk

* Comprueba la normalidad de una variable

```{r}
shapiro.test(starwars$height)
```

#### Prueba chi-cuadrado de Pearson 

* Prueba no paramétrica que se utiliza para probar la independencia de dos variables entre sí, mediante la presentación de los datos en tablas de contingencia.
* Hipótesis nula = independencia vs Hipotesis alternativa = dependencia

```{r}
tt <- table(starwars$gender, starwars$hair_color)
chisq.test(tt)
```

#### ANOVA

* Constituye la herramienta básica para el estudio del efecto de uno o más factores (cada uno con dos o más niveles) sobre la media de una variable continua.

```{r}
library(ggplot2)
ggplot(data = starwars, aes(x = gender, y = height, color= gender)) +
  geom_boxplot()

anova <- aov(iris$Petal.Length ~ iris$Species)
summary(anova)
```


## Regresiónes

#### Regresión Lineal simple

* $y = a+bX$

```{r}
SW <- starwars %>% 
  select(height:species) %>% 
  mutate(hair_color = as.factor(hair_color), 
         skin_color = as.factor(skin_color), 
         eye_color = as.factor(eye_color), 
         gender = as.factor(gender), 
         homeworld = as.factor(homeworld), 
         species = as.factor(species))

pairs(SW)

plot(SW$height ~ SW$mass)

mod0 <- lm(SW$height ~ SW$mass, data = iris)
summary(mod0)

mode(mod0)
mod0$coefficients

confint(object = mod0, level = 0.95 ) #Intervalo de confianza de los coeficientes de la regressión 

plot(mod0) # Diagnóstico del modelo:
```

```{r}
starwars$name[starwars$mass == 1358]

SW <- SW[-which(starwars$mass == 1358),]
plot(SW$height ~ SW$mass)

mod0_1 <- lm(SW$height ~ SW$mass, data = iris)
summary(mod0_1)

mod0_1$coefficients

confint(object = mod0_1, level = 0.95 ) #Intervalo de confianza de los coeficientes de la regressión 

plot(mod0_1) # Diagnóstico del modelo:
```


* $\text{height} = 103.5133 + 0.9327 \cdot \text{mass} $
* Podemos graficarlo:

```{r}
plot(SW$height ~ SW$mass)
abline(mod0_1)
```

* Calcular predicciones: 

```{r}
# Creamos un data.frame con los valores de la variable independiente de los que queremos hacer la predicción:
nuevas <- data.frame(mass = c(80, 60, 20))

# Calculamos las predicciones:
predict(mod0_1, nuevas)
```

#### Regresión Lineal múltiple


```{r}
mod1 <- lm(height ~ mass + gender, data = SW)
summary(mod1)
confint(object = mod1, level = 0.95 )
plot(mod1)

# Predicciones:
nuevas <- data.frame(mass = c(80, 60, 20), gender = c('male', 'female', 'female'))
predict(mod1, nuevas)
```

#### Regresión Logística
```{r}
SW$gender <- car::recode(SW$gender, "'none' = NA")
SW$gender <- factor(SW$gender)

mod2 <- glm(gender ~ height + mass + hair_color + eye_color + birth_year, data = SW, family="binomial")
summary(mod2)
plot(mod2)

exp(mod2$coefficients)
```


# Apéndice

* **Ojo**: 
    + Hay una cantidad enorme de librerías, muchas de las cuales comparten funciones (porque unas llaman a otras), pero también muchas de las cuales comparten nombres de funciones que son distintas (como muestra la advertencia al cargar la librería con funciones que ya están en el entorno). 
    + Por ejemplo, las librerías `plyr` -que no veremos- y `dplyr` -la veremos abajo- comparten varias funciones, entre ellas `rename`. Si se tienen ambas librerías cargadas y R entiende que `rename` se refiere a la función de `plyr`, pero la usamos como la función de `dplyr`, es probable que se produzca un error.
    + Es de los más frecuentes y extraños, por ello hay varias maneras de solucionarlo.

```{r, echo=TRUE}

lapply(paste('package:',names(sessionInfo()$otherPkgs),sep=""),detach,character.only=TRUE,unload=TRUE)

library(dplyr)
library(plyr)
?rename # con la ayuda podemos ver que esta función está en varias librerías actualmente cargadas

names(mtcars)
names(rename(mtcars, x = gear)) # error
names(dplyr::rename(mtcars, x = gear)) # especificamos que la función que queremos es la de dplyr
names(plyr::rename(mtcars, x = gear)) # comprobamos que la función que estaba usando antes era la de plyr, ya que genera el mismo error
rename <- dplyr::rename # otra solución es asignar al nombre la función de dplyr
names(rename(mtcars, x = gear)) # ya no hay error


detach("package:plyr", unload=TRUE)
detach("package:dplyr", unload=TRUE)


```
