---
title: "Introducción a R"
author: Iago Giné Vázquez
date: 2021-10-26/27
autosize: true
width: 2560
height: 1440
css: RCP.css
output: slidy_presentation
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo=TRUE, eval=FALSE)
options(width=240, tibble.width=140)
#https://stackoverflow.com/questions/39996042/disable-mouse-click-to-show-another-slide-in-rmarkdown-slidy-presentation
```



## The R Project for Statistical Computing

<img src="https://www.r-project.org/logo/Rlogo.svg" width="150" height="150">
<!-- ![Alt text](https://www.r-project.org/logo/Rlogo.svg) -->

- https://www.r-project.org
- Software estadístico libre, abierto y gratuito
- Miles de librerías y proyectos complementan el software base en distintas plataformas:
    + [CRAN](https://cran.r-project.org/)
    + [R Forge](https://r-forge.r-project.org/)
    + https://www.bioconductor.org/
- Una publicación:
    + [R News](https://www.r-project.org/doc/Rnews/index.html) (2001 - 2008)
    + [R Journal](https://journal.r-project.org/archive/) (2009 - presente)
- Una gran comunidad de usuarios escribe en blogs y foros:
    + https://www.r-bloggers.com/
    + https://rweekly.org/
    + https://stackoverflow.com/questions/tagged/r
- Por qué R?
    + Porque podéis escribir las instrucciones en R scripts, y ejecutarlas todas de una vez, sin tener que memorizar y repetir cada uno de los pasos.
    + Porque en Internet podréis encontrar solución a (casi) todos los problemas que os encontréis
    + Porque podréis personalizar/modificar cada instrucción con las opciones deseadas.
    + Porque podéis trabajar con más de una base de datos abierta simultáneamente y no tienen que estar guardadas en un formato específico para poder abrirlas.


## R como calculadora

- R es esencialmente una consola en la que el cursor se sitúa tras el símbolo `>`. Ahí se escriben las instrucciones. Se ejecutan con `Enter`.
- Los resultados suelen aparecer debajo. En el caso de gráficas, depende del entorno en que se trabaje (R, RStudio, R Commander, etc.)
- Para empezar, R permite realizar las operaciones de cualquier calculadora científico.
- Incluye además instrucciones específicas para operaciones estadísticas.

<img src="Rterm2.png" width="750" height="700">

```{r, echo=FALSE, eval=FALSE}
install.packages("tidyverse") # instala la librería tidyverse, que a su vez instala las librerías dplyr, tidyr, haven, y otras 
```


## Necesitamos un editor

- Más práctico: ejecutar múltiples operaciones simultáneamente.
- Para ello: se escriben todas en un fichero de texto simple, pero con extensión `.r` en lugar de `.txt`.
- Es suficiente un editor de texto simple. En Windows: **Bloc de notas** (en OS X: **TextEdit**). Los editores con formatos complejos como Microsoft Word no valen.
- Otros editores facilitan la introducción y ejecución de las instrucciones.
- Ej.: **Notepad++**, **Sublime Text**, **Visual Studio Code**, **Geany**, **Nano**, **Emacs**, **VIM**, ...
- Enfocado al uso de **R** y el más usado para ello: **RStudio** (nombre del editor y de la empresa que lo produce y comercializa).
    + RStudio es una interfaz que tiene el objetivo de facilitar y agilizar el uso de R y otros formatos que interactuan con R (documentos pdf, archivos word, páginas y aplicaciones web, etc., todos ellos con código R ejecutado).
    + En particular ofrece menús para especificar el directorio de trabajo, instalar, actualizar y/o cargar librerías, y abrir y visualizar bases de datos, entre otros. Asímismo dispone de atajos de teclado para introducir los comandos más habituales de manera más rápida.
    + RStudio no es software libre, aunque su edición básica es de código abierto y gratuita.
    + https://www.rstudio.com/

<div style="display: flex; align-items: flex-start;">
<img src="4panels1.png" width="900" height="500">
<div>
- Permite tener un fichero con extensión `.r` en el que se puede escribir el código (con autocompletado) y ejecutarlo
- Permite añadir instrucciones mediante [atajos de teclado](https://support.rstudio.com/hc/en-us/articles/200711853-Keyboard-Shortcuts)
</div>
</div>


## Algunas nociones sobre RStudio

- Las instrucciones en el R-script en RStudio se ejecutan con `Control+Enter`

<img src="4panels2.png"  width="1321" height="731">


## Qué es lo primero que nos encontramos en R? Objetos, funciones, comentarios, (directorios) y librerías

- Objetos elementales:
    + Numéricos, como en una calculadora (vimos algunos hace unas diapositivas)
    + Cadenas de texto, siempre limitadas por comillas simples o dobles, desde un carácter, por ejemplo `"a"`, o `'z'`, hasta un texto largo como `"Lorem ipsum dolor sit amet..."` o `'Lorem ipsum dolor sit amet...'`
- Funciones: ejecutan las instrucciones que las definen. Genéricamente se ejecutan escribiendo el nombre de una función `f` seguido de los objetos o valores que necesita entre paréntesis. 
    + Cuando no es necesario ningún valor, estos paréntesis se escriben sin incluír nada, así: `f()`
    + En la mayoría de casos, necesitan evaluar objetos. La evaluación de un objeto `x` con una función `f` se codifica `f(x)`. 
- Un comentario es un fragmento de código, texto... no ejecutable. Se señalan situando a la izquierda un símbolo `#`
- Directorio de trabajo: el entorno de R tiene como referencia un directorio concreto. Esto nos permite no tener que introducir la dirección de la carpeta cuando queremos acceder a algún elemento de esta (por ejemplo, ficheros con bases de datos). 
    + Para saber cuál es el directorio de trabajo actual utilizamos la función `getwd`;
    + Para cambiar el directorio se utiliza la función `setwd` evaluando la dirección del directorio de trabajo en que queremos situarnos ahora;
    + Se puede saber qué archivos hay en el directorio donde R está trabajando con la función `list.files`;

```{r}

getwd() # el directorio donde R está trabajando
setwd("P:/projects/Curso-R") # (en Windows) se tienen que sustituir los \ por /
list.files()

```

O bien, mediante RStudio:

    `Session > Set Working Directory > Choose Directory`
    `Session > Set Working Directory > To Source File Location`
    
- Librerías:
    + Para instalar una librería llamada `tidyverse` evaluamos con la función `install.packages` la cadena consistente en el nombre de la librería, `"tidyverse"`;
    + Para cargar una librería llamada `readxl`, evaluamos con la función `library` (o bien `require`, una función distinta), bien la cadena con el nombre de la librería `"readxl"` o bien (el nombre de) la librería misma, `readxl`.

```{r echo=TRUE, eval=FALSE}

install.packages("tidyverse") # instala la librería tidyverse, que a su vez instala las librerías readxl, dplyr, tidyr, haven, y otras (https://www.tidyverse.org, https://github.com/tidyverse/tidyverse)
library(readxl)
# library("readxl")
# require(readxl)
# require("readxl")
# (.packages()) # vemos qué librerías tenemos cargadas en este momento

```

```{r, echo=FALSE, eval=TRUE, include=FALSE}
library(readxl)
```

O bien, mediante RStudio:

    Panel `Packages > Install`



## Siguientes pasos: formas de obtener ayuda, argumentos de una función y abrir un fichero con formato de Excel

- R dispone de una ayuda muy completa sobre todas las funciones, procedimientos y elementos que configuran el lenguaje
- Se puede acceder a ella con la función `help()` o mediante `?`. Los siguientes ejemplos nos muestran los documentos de ayuda de las respectivas funciones. 

```{r, eval=FALSE}

help(install.packages)
?library

```

- Para evaluar un objeto mediante una función, implícitamente estamos asignando el objeto a un argumento de la función. Por ejemplo, al ejecutar `library(readxl)` asignamos (el nombre de) la librería `readxl` al primer argumento de la función `library`, que es `package`. Entonces, otra forma de ejecutar `library(readxl)` es ejecutar `library(package = readxl)`. En este caso, es exactamente lo mismo, pero cuando queremos usar otro argumento de una función distinto del primero en general tenemos que nombrarlo.
- Además de las funciones, entre otros objetos de los que podemos ver documentos de ayuda están las librerías.

```{r eval=FALSE}

?help
help(package = "readxl") # Informémonos acerca de la librería readxl
?read_excel # ayuda de la función read_excel

```


Para abrir ficheros de excel disponemos de diversas funciones en las librerías `readxl` y `openxlsx` entre muchas otras. Aunque la segunda librería tiene más funciones y opciones para manipular y escribir ficheros `.xlsx`, la primera dispone de funciones que nos permiten leer también ficheros `.xls`. En cualquier caso, estas funciones evalúan, bien la dirección absoluta del fichero que hay que abrir, bien la dirección relativa con respecto al directorio de trabajo de R como en el siguiente ejemplo.

```{r, eval=TRUE}
read_excel("data_curs_stat/EP1.xls")
```

**Nota:** _Para abrir ficheros `*.csv` disponemos de la función `read.csv` en R, de la función `read_csv` en la librería `readr` y de la función `fread` en la librería `data.table` entre otras. La librería `haven` dispone de diversas funciones que permiten abrir y escribir ficheros en formatos de Stata, SPSS y SAS (pueden consultarse en su ayuda, `package(help = "haven")`). Por otra parte la librería `readspss` (https://github.com/JanMarvin/readspss) tiene funciones que permiten abrir bases de datos en formato de SPSS encriptadas con contraseña. Podemos encontrar más información en esta [breve introducción a R](https://people.umass.edu/biep640w/pdf/R%20handout%202018%20Dataset%20Basics.pdf)_


## Abrir bases de datos y ejecutar funciones: R no es como Stata.


La función `read_excel` abre la base de datos, pero a diferencia de instrucciones como `use` o `import excel` en Stata, no la copia a memoria. Así, si en Stata podríamos ejecutar `describe` o `summarize`, si en R ejecutamos una función como `summary` el resultado es la propia función.
```{r eval=TRUE}
summary
```

Tenemos que evaluar la base de datos que abrimos con `read_excel` con la función `summary`:
```{r eval=TRUE}
summary(read_excel("data_curs_stat/EP1.xls"))
```

Abrir la base de datos mediante la función `read_excel` cada vez que queremos operar con ella no es práctico. En lugar de esto, guardamos la base de datos en una variable.


**Ejercicio:**

*Instalar la librería `openxlsx` y buscar la ayuda de sus funciones `read.xlsx` y `loadWorkbook`*


## Objetos complejos. Clases. Bases de datos


R es un lenguaje de programación que nos permite acceder a objetos con distintas estructuras y manipularlos. Los [tipos de objetos](https://stat.ethz.ch/R-manual/R-devel/doc/manual/R-lang.html#Basic-types) más importantes son:

- El **vector**, una colección de datos elementales del mismo tipo básico ordenados. 
    + Los tipos básicos más comunes son:
        * Numérico
        * Cadena de texto o caracteres
        * Lógico: `TRUE`, `FALSE` y `NA` (missing)
        * Entero, para números exclusivamente enteros
    + Habitualmente, los vectores se crean y se unen con la función `c`
- La **lista**, una colección de objetos de cualquier tipo. Habitualmente se crean mediante la función `list`
- La **función**
- El símbolo, el nombre de un objeto
- El objeto nulo o vacío, `NULL`

La mayoría de los objetos pueden tener [atributos](https://stat.ethz.ch/R-manual/R-devel/doc/manual/R-lang.html#Attributes), como pueden ser las dimensiones o las etiquetas. De esta manera se pueden crear objetos con [estructuras más complejas](https://stat.ethz.ch/R-manual/R-devel/doc/manual/R-lang.html#Special-compound-objects):

- **Matrices**  (resp. **arrays**), son vectores ligados a un atributo `dim` incluyendo las 2 (resp. -) dimensiones del objeto. Podemos crear matrices mediante la función `matrix`.
- **Factores**, vectores con un atributo `levels` que corresponde a las posibles categorías de una variable categórica y un atributo `class="factor"`. Por defecto son nominales, pero también pueden tener categorías ordenadas, caso en el que el atributo `class` es el vector `c("ordered"," factor")`
- **Fechas/Horas**: hay 2 representaciones principales (ejecutando `?DateTimeClasses` puede verse más información)
    + vectores de tipo numérico (o entero), representando el número de segundos (resp. días) desde 1970-01-01 UTC, con clase `POSIXct` (resp. `Date`)
    + listas, cuyos objetos son los distintos elementos del momento representado (año, mes, día, hora, minuto, segundo, etc.), con clase `POSIXlt`
- **Data frames**, el tipo básico de base de datos en R. Es una lista de vectores (las columnas de la base de datos) -que pueden ser matrices o factores- que tienen todos la misma longitud, con un atributo `names` que designa los nombres de las columnas o variables de la base de datos y un atributo `row.names` que designa las filas u observaciones. Podemos crearlos mediante la función `data.frame`

Disponemos de un conjunto de [operadores](https://stat.ethz.ch/R-manual/R-devel/doc/manual/R-lang.html#Operators) en R <!--(cf. `?Syntax`) -->que nos permiten acceder y manipular los objetos. Además de los operadores aritméticos y lógicos, entre otros disponemos de los siguientes:

- `<-`, para asignar un nombre a un objeto. Por ejemplo, `x <- c(3,log(4), 5.2)`, `y <- list(3, 'a', list(TRUE))`, `M <- matrix(c(1,2,3,4), nrow = 2, ncol = 2, byrow=TRUE)`
- `[`, para acceder a un elemento de un vector o a una sublista. Por ejemplo, `x[3]`, `y[2]`, `y[3]`, `M[,2]` o `M[1,2]`
- `[[`, para acceder a un elemento en una lista. Por ejemplo, `y[[2]]`




## Otras características y algunas funciones prácticas

- Los missings en R se representan con el símbolo `NA`, existente para los distintos tipos básicos, o también  `NaN` en el caso de objetos numéricos.
- Podemos nombrar los elementos de un vector o lista con la forma `nombre = elemento`. Por ejemplo ``y <- list(numero = 3, `letra` = 'a', "sublista" = list(TRUE))``. 
- Cuando tenemos un vector o lista con nombres (como es el caso de cualquier data frame):
    + podemos usar el nombre (como cadena de caracteres) en lugar del índice para acceder a los elementos del vector o a las sublistas. Por ejemplo `y[c("letra", 'sublista')]`.
    + en el caso de listas también podemos acceder a sus elementos mediante los operadores`[[` o `$`. Por ejemplo  `y[['letra']]` o `y[["sublista"]]`, o equivalentemente `y$letra` o `y$sublista` (o ``y$`letra` `` o ``y$`sublista` ``).
- Habitualmente es suficiente ejecutar el nombre de un objeto para ver el objeto. En cierta ocasiones conviene evaluarlo explícitamente con la función `print`.
- Otras funciones (principalmente informativas):
    + Podemos informarnos acerca de la longitud, clase, estructura y atributos de un objeto por medio de las funciones `length`, `class`, `str` y `attributes` respectivamente. 
    + La función `names` nos permite conocer los nombres de los elementos de un objeto, como pueden ser las variables de un data frame.
    + La función `levels` evaluada en un factor retorna las categorías del factor.
    + Mediante `dim` vemos las dimensiones de un objeto, como pueden ser las filas y columnas de una matriz o de un data frame. Para objetos similares, `dimnames` informa acerca de los nombres de las filas y columnas.
- Funciones de tipo `is` y `as`. 
    + Las funciones `is` permiten verificar que un objeto es de una determinada clase. Algunos ejemplos:
        * Es missing un elemento?: `is.na(y)`
        * Es un vector de tipo carácter o numérico?: `is.character(y$numero)`, `is.numeric(y$letra)`
        * Es un data frame?: `is.data.frame(y)`
    + Las funciones `as` fuerzan a los objetos a transformarse a la clase especificada cuando esto es posible.
        * Transformar a cadenas de caracteres. Por ejemplo, `as.character(y)`
        * Transformar a números. Por ejemplo, `as.numeric(list("3", TRUE, FALSE, "a"))`
        * Interpretar una cadena de texto como fecha. Por ejemplo, `as.Date("01/05/1965", "%m/%d/%Y")`
        * Transformar una matriz a data frame, por ejemplo `as.data.frame(M)`
- Funciones para generar sucesiones de números y generar nuevos vectores:
    + `seq` genera una sucesión de números desde uno inicial hasta uno final, y permite especificar o el tamaño de los intervalos o la longitud de la sucesión. Por ejemplo `seq(from = 5, to = 20, by = 2)`
    + el operador `:` también permite generar sucesiones de números enteros. Por ejemplo, `5:20`
    + `rep` genera un vector de elementos a partir de un vector inicial dado. Por ejemplo, `rep(x = c(1,3,5), times = 2)` o `rep(c(1,3,5), each = 5)`.
    + `paste` y `paste0` combinan cadenas de caracteres según se especifique. Por ejemplo, `paste(y$letra, c(1,2))`


**Ejercicio:**

*Buscar en la ayuda de las funciones presentadas qué opciones presentan según como se especifiquen sus argumentos. Para qué sirven las funciones `seq_len` y `seq_along`?*

## Primeros pasos con una base de datos. 

Asignamos la base de datos a una variable que llamamos `dataw1`. A partir de este momento tenemos un objeto de R con nombre `dataw1`, ya no es una base de datos en excel.

```{r eval=TRUE}
dataw1 <- read_excel("data_curs_stat/EP1.xls", sheet = 1) # aunque en este caso no es necesario, especificamos también que abrimos la hoja 1 del fichero excel
class(dataw1)
length(dataw1)
names(dataw1)
str(dataw1)
head(dataw1) # primeras (6) filas
# head(dataw1, 3) # primeras 3 filas
# tail(dataw1) # últimas (6) filas
# View(dataw1) # vemos la base de datos completa

```

**Ejercicio:** 

*Usando las funciones `setwd` y `read_excel` convenientemente (hay varias posibilidades), guardar también las bases de datos `EP2.xls` y `EP3.xls` en dos variables que llamaremos `dataw2` y `dataw3`. Podéis ver `dataw1`, `dataw2`, `dataw3` y sus dimensiones en el panel `Environment` de RStudio?*

```{r echo=FALSE, eval=TRUE}
dataw2 <- read_excel("data_curs_stat/EP2.xls")
dataw3 <- read_excel("data_curs_stat/EP3.xls")

```




## Acceso a las variables de una base de datos: los operadores `$` y `[[`

```{r eval=TRUE}
# dataw1$phys_hea1
# dataw1[["phys_hea1"]]
class(dataw1$phys_hea1)
#summary(dataw1$phys_hea1)
str(dataw1$phys_hea1) # chr quiere decir que phys_hea1 es una variable carácter, es decir, un vector de tipo cadena de carácteres
attributes(dataw1$phys_hea1)
table(dataw1$phys_hea1)
table(dataw1$phys_hea1, useNA = "ifany")
prop.table(table(dataw1$phys_hea1))
```

Es posible introducir diferentes instrucciones en una misma línea separadas por `;` (indiferentemente de los espacios en blanco en medio)
```{r eval=TRUE}
class(dataw1$hea1); str(dataw1$hea1) # num quiere decir que hea1 es una variable numérica
summary(dataw1$hea1)
#?table
```


## Otras funciones y [operadores](https://stat.ethz.ch/R-manual/R-devel/doc/manual/R-lang.html#Operators) lógicos y aritméticos en R

- Operadores aritméticos: `+`, `-`, `*`, `/`, `%%` (residuo), `^` (potencia)
- Algunas funciones aritméticas: `sum`, `round`, `floor`, `log`, `log10`, `log2`, `exp`, `sqrt`, `factorial`
- Operadores lógicos: `==` (igualdad), `!` (negación), `!=` (no igualdad), `<`, `<=`, `>`, `>=` (desigualdades), `%in%` (pertenencia), `|`, `||` (o), `&`, `&&` (y)

```{r, echo=TRUE, eval=TRUE}

3 %in% c(1:5)
!3 %in% c(1:5)
3 %in% c(5:50)
!3 %in% c(5:50)

TRUE & TRUE
TRUE & FALSE
FALSE | FALSE
FALSE | TRUE



x <- c(1,3,5,7, NA, 8,5, NA)
sum(is.na(x))

```

**Ejercicio:**

- *Si hemos afirmado que un vector creado con la función `c` tiene todos los elementos del mismo tipo y que `NA` es un elemento de tipo lógico, por qué la instrucción `c(1,3,5,7, NA, 8,5, NA)` no da lugar a un error?*
- *Los operadores lógicos* `|` *y* `||` *, y* `&` *y* `&&` *se diferencian cuando comparan vectores lógicos con más de un elemento, como por ejemplo `c(TRUE, FALSE)`. Cuáles son esas diferencias?*

**Nota:** *para buscar la ayuda de un operador como* `|` *podemos ejecutar la instrucción* `` ?`|` ``



## Transformación de variables. Factores

- La función `as.factor` permite transformar a un factor, objeto que codifica una variable categórica:
```{r eval=TRUE}
class(as.factor(dataw1$phys_hea1))
str(as.factor(dataw1$phys_hea1))
attributes(as.factor(dataw1$phys_hea1))
table(as.factor(dataw1$phys_hea1), useNA = "ifany")
levels(as.factor(dataw1$phys_hea1))
```

Si nos interesa un atributo concreto, usamos la función `attr`:

```{r eval=TRUE}
attr(as.factor(dataw1$phys_hea1), "class")
attr(as.factor(dataw1$phys_hea1), "levels")
```





## Transformación de variables. Factores ordenados

Del mismo modo que podemos encontrarnos con variables categóricas ordenadas, como es el caso de las escalas de tipo Likert, los factores pueden ser ordenados. En este caso podemos utilizar la función `as.ordered`, aunque ésta puede ordenar las categorías erróneamente. 

```{r eval=TRUE}
attributes(as.ordered(dataw1$phys_hea1))
str(as.ordered(dataw1$phys_hea1))
```

Ante ello, es preferible construír el factor especificando el orden que nos interesa:

```{r eval=TRUE}

x <- factor(dataw1$phys_hea1, ordered = TRUE, levels = c("None", "1 physical health problem", "2+ physical health problems"))
str(x)
attributes(x)
levels(x)
table(x, useNA = "ifany")

```


## Transformación de una variable en una base de datos (con la librería `dplyr`)

```{r echo=FALSE, eval=TRUE, include=FALSE}
library(dplyr)
```

Guardamos la transformación en la base de datos. Para ello usaremos la función `mutate` de la librería `dplyr`, que permite realizar varias transformaciones separadas por comas
```{r eval=FALSE}
library(dplyr)
#?mutate

dataw1 <- mutate(dataw1, phys_hea1 = as.factor(phys_hea1))

# es lo mismo que:

dataw1 <- dataw1 %>% mutate(phys_hea1 = as.factor(phys_hea1))

# podemos escrbir el argumento a la derecha de %>% en las líneas inferiores

dataw1 <- dataw1 %>% #partimos de la base de datos dataw1 y entonces
  mutate(phys_hea1 = as.factor(phys_hea1)) # transformamos la variable y la guardamos con el mismo nombre

# finalmente la base de datos queda guardada con el mismo nombre mediante la asignación inicial (dataw1 <- ...)
```

+ El primer argumento o valor de la función `mutate` es la base de datos o data frame.
+ Los siguientes argumentos son las transformaciones `variable_output = transformación` separadas por comas.
+ Usando el operador `%>%`, la función situada en el lado derecho (en este caso `mutate`) ya reconoce que su primer argumento es el valor situado en el lado izquierdo de `%>%` (en este caso `dataw1`)
+ Usamos la librería `dplyr` porque incluye otras funciones que facilitan realizar diversas operaciones y que veremos más adelante, de manera que usemos un lenguaje consistente. Sin embargo, podríamos escribir la instrucción especificada encima sin acudir a ninguna librería:

```{r eval=FALSE}
# Forma simple
dataw1$phys_hea1 <- as.factor(dataw1$phys_hea1)

# Usando la función transform
dataw1 <- transform(dataw1, phys_hea1 = as.factor(phys_hea1))
```

Y a partir de la versión 4.1.0, R dispone del nuevo operador `|>`:

```{r eval=FALSE}
dataw1 <- dataw1 |> transform(phys_hea1 = as.factor(phys_hea1))
```


## Pipe

<div style="position: relative; top: 0px;">
<img style="float: left;" src="pipe.jpg" width="560" height="420">
<img style="float: right;" src="rpipe.png" width="368" height="426">
</div>

<div style="clear:both;"></div>

<div style="display: flex; align-items: flex-start;">
<div>
```{r, echo=TRUE, eval=TRUE}
head(names(dataw1))

dataw1 %>% # la pipa más habitual: envía los datos de la izquierda a la función que sigue (a la derecha o abajo) y retorna su evaluación
  names() %>% # esta pipa está incluida en la librería dplyr, pero es original de la librería magrittr
  head()

library(magrittr)
# dataw1 %T>% # como la pipa anterior, pero retorna de nuevo los datos de la izquierda
#   View() %>% # sirve para usar los datos en más de una función, cuando las intermedias no retornan nada, como View, plot, ...
#   names() %>%
#   head()

```


</div>
<div>
```{r, echo=TRUE, eval=TRUE}

dataw1 %$% # para funciones sin un argumento para data.frame's
  table(edu1, phys_hea1)

dataw1 %<>%
  mutate(phys_hea1 = as.factor(phys_hea1)) # la asignación está incluida en la pipa; 

# es lo mismo que
# dataw1 <- dataw1 %>% mutate(phys_hea1 = as.factor(phys_hea1))
```
</div>
</div>

**Nota:** *la pipa `%>%` puede ser problemática con algunas funciones, como por ejemplo `save`. La pipa de R base `|>`, aunque no se puede utilizar para determinadas estructuras más complejas, es más segura. Por ejemplo, `dataw1 |> save(file = "datos.Rdata")` es exactamente lo mismo que `save(dataw1, file = "datos.Rdata)`, pero `dataw1 %>% save(file = "datos.Rdata")` implica una instrucción ligeramente distinta.*


## Transformación de varias variables en una base de datos con la librería `dplyr`


Como la variable `q0002_hhid` es un id podría interesarnos que fuera de clase cadena
```{r}
#class(dataw1$q0002_hhid)
#?as.character
```


Varias transformaciones seguidas las podemos evaluar:

- Aplicando varias veces `mutate`:

```{r eval=FALSE}

dataw1 <- dataw1 %>% #partimos de la base de datos dataw1 y entonces
  mutate(phys_hea1 = as.factor(phys_hea1))  %>% # transformamos la variable phys_hea1 y la guardamos con el mismo nombre, y entonces
  mutate(dep1 = as.factor(dep1)) %>% # transformamos la variable dep1 y la guardamos con el mismo nombre, y entonces
  mutate(q0002_hhid = as.character(q0002_hhid)) # transformamos la variable q0002_hhid y la guardamos con el mismo nombre

```

- Pero en lugar de eso, habitualmente se separan las instrucciones por comas en un sólo `mutate`:

```{r eval=FALSE}

dataw1 <- dataw1 %>% #partimos de la base de datos dataw1 y entonces
  mutate(phys_hea1 = as.factor(phys_hea1), dep1 = as.factor(dep1), q0002_hhid = as.character(q0002_hhid)) # transformamos las variables phys_hea1,  dep1 y q0002_hhid y las guardamos con los mismos nombres

```

- O bien, cuando estamos aplicando la misma transformación (en este caso `as.factor`) a varias variables (y guardándolas con el mismo nombre), podemos usar `across(vector de variables, función)` dentro de `mutate`:

```{r eval=FALSE}
dataw1 <- dataw1 %>% #partimos de la base de datos dataw1 y entonces
  mutate(across(c(phys_hea1, dep1), as_factor), q0002_hhid = as.character(q0002_hhid)) # evaluamos as_factor a través de las variables phys_hea1 y dep1 y transformamos también number_id
```

**Ejercicio:** 

- *Buscar todas las variables categóricas en las 3 bases de datos y transformar estas bases de datos de manera que esas variables sean factores. Mostrar las frecuencias de las categorías de algunas de esas variables. Transformar la variable `q0002_hhid` a cadena de carácteres. Consultar también la ayuda de `as.numeric`, `as.integer` y `as.factor`*
- *Qué hace la función transmute?*


**Nota:** *Dentro de la función `across`, podemos seleccionar las variables que nos interesan de formas alternativas a escribir un vector de variables como `c(phys_hea1, dep1)`. Veremos una introducción a estas alternativas en la siguiente diapositiva*

```{r echo=FALSE, eval=TRUE, include=FALSE}
dataw1 <- dataw1 %>%
  mutate(across(c(sex, age, mar_1, edu1, phys_hea1, dep1, income_inf1), as.factor), q0002_hhid = as.character(q0002_hhid))

dataw2 <- dataw2 %>%
  mutate(across(c(phys_hea2, dep2), as.factor), q0002_hhid = as.character(q0002_hhid))

dataw3 <- dataw3 %>%
  mutate(across(c(dep3, phys_hea3), as.factor), q0002_hhid = as.character(q0002_hhid))

```



## Otras operaciones con funciones de la librería `dplyr`: selección de variables

**Selección** de variables

```{r eval=TRUE}

dataw1 %>% #partimos de la base de datos dataw1 y entonces
  select(q0002_hhid, hea1, dep1) %>% # mantenemos sólo las columnas q0002_hhid, hea1 y dep1, y entonces
  names() # miramos qué nombres tienen

dataw1 %>%
  select(ends_with("1")) %>% # seleccionamos todas las variables cuyo nombre acaba en 1, y entonces
  names() # miramos qué nombres tienen
```

**Nota:** *Podemos seleccionar variables por índice y por nombre. Por ejemplo, para las 3 primeras variables escribiríamos `select(1:3)`.*

**Ejercicio:**

- *Qué ocurre si escribimos un `-` delante de `end_with`?*
- *De qué otras funciones similares a `ends_with` disponemos?*
- *Seleccionar todas las variables numéricas sin nombrarlas*


**Pull**. Una función en `dplyr` para el operador `$`

```{r, eval=TRUE}

dataw1 %>% pull(phys_hea1) %>% str()

```

Posibles combinaciones **distintas** de edad, educación y depresión

```{r, eval=TRUE}

dataw1 %>% distinct(age, edu1, dep1)

```



## Otras operaciones con funciones de la librería `dplyr` y funciones de R para el cálculo de estadísticos

- Ejemplo 1

```{r eval=TRUE}

dataw1 %>% #partimos de la base de datos dataw1 y entonces
  select(q0002_hhid, hea1, dep1) %>% # mantenemos sólo las columnas q0002_hhid, hea1 y dep1, y entonces
  filter(dep1 == "Yes") %>% # nos quedamos con las filas de quienes padecen depresión, y entonces
  arrange(desc(hea1)) %>% # ordenamos las filas por de mayor a menor valor de estado de salud, y entonces
  head(3) # nos quedamos con los 3 pacientes con depresión con mayor valor de Health state

```



- Ejemplo 2 (uso de funciones de R como `mean`, `median` o `quantile`; se pueden usar otras como `var`, `sd`, `min`, `max`, `IQR`, etc.)

```{r eval=TRUE}

dataw1 %>% #partimos de la base de datos dataw1 y entonces
  select(q0002_hhid, hea1, dep1, score_lon1) %>% # mantenemos sólo las columnas number_id, hea1 y dep1, y entonces
  group_by(dep1) %>% # agrupamos por las categorías de depresión, y entonces
  summarise(mean_hea1 = mean(hea1, na.rm = TRUE), median_hea1 = median(hea1, na.rm = TRUE), tercil_hea1 = quantile(hea1, probs = 1/3, na.rm = TRUE), n = n(), distinct_score_lon1 = n_distinct(score_lon1)) 
# para cada categoría de depresión calculamos media, mediana y primer tercil de hea1,
# número de observaciones y número de observaciones distintas de score_lon1

dataw1 %>% distinct(dep1, score_lon1) %>% group_by(dep1) %>% summarise(n = n())

```

**Ejercicio:**

*Comprender los distintos pasos en la última instrucción y las distintas funciones mencionadas referentes a estadísticos. Mirar también qué hace y cómo se puede usar la función `range`*

**Nota:** *usamos `na.rm = TRUE` dentro de `mean`, de `median` y de `quantile` para que calcule la media de aquellos valores que no son missing. En caso contrario, cuando hay missings el resultado es `NA`.*

**Nota:** *Todo lo anterior se puede realizar también con funciones de R sin necesidad de acudir a la librería `dplyr`, pero las alternativas pueden ser más complejas.*

```{r echo=FALSE, eval=FALSE}
dataw1 |> # partimos de la base de datos dataw1 y entonces
  subset(select = c(hea1, dep1)) |> # mantenemos sólo las columnas hea1 y dep1, y entonces
  transform(dep1 = as.factor(dep1)) |>  # transformamos la variable  dep1 y la guardamos con el mismo nombre, y entonces
  stats:::aggregate.formula(formula = hea1 ~ dep1, FUN = "mean") # calculamos la media de hea1 para cada categoría de depresión
```

## Cálculo de prevalencias:

Prevalencia de depresión:
```{r echo=TRUE, eval=TRUE}
dataw1 %>% 
  count(dep1) %>% # Contamos los individuos en cada categoría de depresión y entonces
  mutate(prop = 100*n/sum(n)) # calculamos el %

```

Prevalencia de depresión por grupos de edad y sin tener en cuenta los missings:
```{r echo=TRUE, eval=TRUE}
# ?is.na
dataw1 %>% 
  group_by(age) %>% 
  count(dep1) %>% # Contamos los individuos en cada categoría de depresión por grupo de edad y entonces
  filter(!is.na(dep1)) %>% # eliminamos los missings si nos interesa contar el porcentaje sobre el total de respuestas válidas, y entonces
  mutate(prop = 100*n/sum(n)) # Calculamos el %

```


## Vemos las variables y guardamos los resultados

Hemos dicho que R es como una calculadora, y que si no asignamos los objetos a variables, se muestran en consola pero no quedan guardados en ningún sitio.

- Podemos ver los objetos que hemos creado en el panel `Environment` de RStudio o podemos ver sus nombres todavía con la función `ls`. Se pueden eliminar objetos mediante la función `rm`, separando sus nombres por comas.
- Los objetos de R (como una base de datos o dataframe) se pueden guardar con la función `save` en ficheros con la extensión `.rda` o `.rdata` (aunque a veces también se escribe la `r` e incluso la `d` en mayúscula, por ejemplo `.RData`).
- Los ficheros donde se guardan objetos de R se abren o cargan con la función `load` (o de forma distinta, con la función `attach`).
- Los resultados, si son matrices, data frames o tablas, además, también se pueden guardar en ficheros `.csv` o con formatos de excel. De hecho, a menudo las funciones mencionadas de la forma `read_` o `read.` tienen funciones correspondientes `write_` o `write.`. Por ejemplo, podríamos guardar el data frame `dataw1` en un fichero `csv` con `write.csv`:

```{r, echo=TRUE, eval=FALSE}
# write.csv(dataw1, file = "datos_ola1.csv")
```

- Los resultados y más generalmente todo aquello que aparece por consola puede ser guardados en ficheros de texto con la función `sink`. El primer argumento de esta función es el nombre del fichero donde se guardarán los resultados.
- A no ser que se especifique la dirección del fichero, serán guardados en el directorio donde R está trabajando (`getwd()`)

```{r echo=TRUE, eval=TRUE}
#?sink
sink("Summary_Estudi_poblacional_w1.txt", split = TRUE) # El fichero de texto donde se guardarán los resultados se llamará Summary_Estudi_poblacional_w1.txt, 
# pero podría llamarse como cualquier otro fichero de texto, no hay más restricción para el nombre que las del sistema operativo donde se está trabajando
table(dataw1$phys_hea1)
summary(dataw1$hea1)
sink()
```

**Ejercicio:**

*Qué aparece en el fichero Summary_Estudi_poblacional_w1.txt (o como lo hayáis llamado)?*



## Condiciones y loops

- Condiciones: `if`, `else`, `ifelse` (e `if_else`, la función equivalente en `dplyr`), `case_when` (otra función en `dplyr`)
- Loops: `for`, `while`

```{r, echo=TRUE, eval=TRUE}
y <- x <- as.character(dataw1$edu1); head(x, 10); table(x, useNA = "always")
for(i in seq_along(x)){
  if(is.na(x[i])){
    y[i] <- "Unknown"
  } else if (x[i] == "Less primary" || x[i] == "Primary"){
    y[i] <- "Until primary"
  } else if (x[i] == "Secondary" || x[i] == "Tertiary"){
    y[i] <- "Secondary or higher"
  } else {
    print(x[i]); y[i] <- x[i]
  }
}
head(y, 10); table(y, useNA = "always")

z <- ifelse(x == "Secondary" | x == "Tertiary", "Secondary or higher", "Until primary")
head(z, 10); table(z, useNA = "always")
w <- case_when(is.na(x) ~ "Unknown", 
               x %in% c("Less primary", "Primary") ~ "Until primary", 
               x %in% c("Secondary", "Tertiary") ~ "Secondary or higher", 
               TRUE ~ x)
head(w, 10); table(w, useNA = "always")
```

## Funciones \*apply

- Para aplicar una función a una matriz/data.frame/lista R dispone de las funciones de la familia apply: 
    + lapply: Devuelve una lista de resultados al aplicar una función a un vector o lista.
    + sapply: Si es posible\*, devuelve un vector de resultados al aplicar una función a un vector o lista.
    + apply: Devuelve el vector o la lista de valores obtenidos aplicando una función a un vector o matriz por grupos.
    + tapply: Devuelve una lista con los resultados obtenidos al aplicar una función a un vector por grupos.
    + mapply: Devuelve un vector resultado de aplicar una función a tuplas de elementos en paralelo.
    
```{r, eval=TRUE}

str(dataw1[,c("score_lon1", "score_sup1")])
lapply(dataw1[,c("score_lon1", "score_sup1")], class)
sapply(dataw1[,c("score_lon1", "score_sup1")], class)
str(apply(dataw1[, c("score_lon1", "score_sup1")], 1, sum))
apply(dataw1[, c("score_lon1", "score_sup1")], 2, sum, na.rm = TRUE)
mapply(paste, 1:4, 4:1)

```

\* Del mismo modo que la función `c`, intenta forzar a todos los elementos de la lista inicialmente resultante a tener el mismo tipo, en el orden `NULL` < lógico < entero < numérico < carácter (esencialmente)

## Variables y dimensiones de las bbdd

```{r eval=TRUE}
names(dataw1)
dim(dataw1)
ncol(dataw1)
nrow(dataw1)
names(dataw2)
dim(dataw2)
names(dataw3)
dim(dataw3)
```


## Fusión (merge) de bbdd

Cuántos missings tiene la variable `q0002_hhid`?

```{r eval=TRUE}

table(is.na(dataw1$q0002_hhid)); table(is.na(dataw2$q0002_hhid)); table(is.na(dataw3$q0002_hhid))
```


Ya tenemos las bbdd abiertas y guardadas. Sólo tenemos que unir por la(s) variable(s) identificadora(s), en este caso `q0002_hhid`.
```{r eval=TRUE}
data <- dataw1 %>% # partimos de la base de datos dataw1 y entonces
  full_join(dataw2, by = "q0002_hhid") %>% # unimos horizontalmente con todas las observaciones de dataw2 con q0002_hhid iguales a los de dataw1 y añadimos las nuevas, y entonces
  full_join(dataw3, by = "q0002_hhid") # unimos horizontalmente con todas las observaciones de dataw3 con q0002_hhid iguales a los que ya había y añadimos las nuevas
names(data)
dim(data)
```

```{r}
?full_join
```

**Ejercicio:**

*Con `full_join` creamos una base de datos resultado de fusionar las 3 iniciales e incluír todas las observaciones de cada una de ellas. Consultando en la ayuda, este ejercicio consiste en fusionar las 3 bases de datos, pero incluyendo sólo aquellas observaciones comunes a las 3. Cuántas observaciones tiene?*


## Bases de datos en formato de Stata 

Abrimos las 3 olas de un ensayo clínico en fichero separados. Usamos la función `read_dta` en la librería `haven`. 

- Puede abrir bases de datos guardadas con diferentes versiones de Stata, pero si fueron guardadas con versiones previas a la 14 en Mac o Linux, entonces hay que ajustar el argumento `encoding = "latin1"` (información que proporciona con más detalle la ayuda de la función, `?read_dta`)
- La función `write_dta` permite guardar data frames en formato de Stata para distintas versiones, especificando el argumento `version`.
- Otras librerías que permiten abrir ficheros de Stata son `foreign` y `readstata13`.
    
```{r eval=TRUE}

library(haven)
ac1 <- read_dta("data_curs_stat/Assaig_clinic_w1.dta"); ac2 <- read_dta("data_curs_stat/Assaig_clinic_w2.dta"); ac3 <- read_dta("data_curs_stat/Assaig_clinic_w3.dta")

```

Una base de datos en formato de Stata está guardada de manera distinta que una base de datos en formato de excel. Por ello, al abrirla como un data frame, éste tiene una estructura ligeramente distinta.

Recordemos que cuando abrimos la base de datos que guardamos en el objeto `dataw1`, la variable `phys_hea1` era un vector carácter y sus elementos eran las distintas categorías, de manera que la transformamos de manera razonable en factor mediante la función `as.factor`. Ahora, sin embargo, al abrir bases de datos en formato Stata con la librería `haven` encontramos algunas diferencias

```{r, echo=TRUE, eval=TRUE}
class(ac1$edu1)
str(ac1$edu1)
attributes(ac1$edu1)
table(ac1$edu1)

```

## Variables con etiquetas

En formatos de fichero distintos de excel o `.csv`, como pueden ser los de Stata o SPSS, las categorías de las variables categóricas pueden estar grabadas como etiquetas, mientras los valores son numéricos. 

```{r, echo=TRUE, eval=TRUE}
class(as.factor(ac1$edu1))
str(as.factor(ac1$edu1))
attributes(as.factor(ac1$edu1))
table(as.factor(ac1$edu1))

```

En estos casos, la función `as_factor` de la librería `haven` es más adecuada que `as.factor` para recuperar las etiquetas, ya que, a diferencia de esta última, tiene en cuenta los atributos de la variable original.

```{r, echo=TRUE, eval=TRUE}
class(as_factor(ac1$edu1))
str(as_factor(ac1$edu1))
attributes(as_factor(ac1$edu1))
table(as_factor(ac1$edu1))

```


## Combinar bases de datos

```{r eval=TRUE}

dim(ac1); names(ac1); dim(ac2); names(ac2); dim(ac3); names(ac3)
```

Para poder combinarlas verticalmente, los nombres de las columnas que queremos combinar tienen que ser iguales. Para ello usamos otra función de la librería `dplyr`: `rename`

```{r eval=TRUE}
acr1 <- ac1 %>% # partimos de ac1 y entonces
  rename(hea = hea1) # renombramos hea1 como hea
acr2 <- ac2 %>% # partimos de ac2 y entonces
  rename(hea = hea2, dep = dep2) # renombramos hea2 como hea y dep2 como dea
acr3 <- ac3 %>% 
  rename(hea = hea3, dep = dep3) # mismo proceso para ac3

#names(ac1); names(ac2); names(ac3)
```

Finalmente combinamos las filas con otra función de la librería `dplyr`: `bind_rows`

```{r eval=TRUE}
#?bind_rows
acv <- bind_rows(acr1, acr2, acr3, .id = "wave")
```

## Otras opciones para combinar bases de datos

**Ejercicio:**

*Ver qué variables tiene `acv`; para qué se añadió `.id = "wave"`?; ejecutar `rbind(ac1,ac2,ac3)`*


**Nota:** _La función `rbind` de R hace esencialmente lo mismo, pero necesita que las 3 bases de datos tengan exactamente las mismas columnas. En caso en que esto no ocurre, como el presente, da un error. Además, tanto en el caso de `rbind` como de `bind_rows`, conviene que las columnas por las que se combina (las de igual nombre) tengan la misma clase, pues en caso contrario pueden ocurrir errores o comportamiento extraños._


**Nota:** *Las funciones `cbind` y `bind_cols` de R y `dplyr` respectivamente combinan por columnas. Se diferencian de un merge en que no hay una columna "común" por la que fusionar, sino que se añaden las columnas de los distintos objetos, tal como están ordenadas en cada uno de ellos. Además, todas las columnas tienen que tener el mismo número de elementos.*


Fusionamos horizontalmente las 3 bbdd originales de los ensayos clínicos. En este caso no las podemos combinar porque tienen distinto número de filas:

```{r eval=TRUE}
ach <- ac1 %>%
  full_join(ac2, by = c("q0002_hhid", "number_id", "ID_ECS", "grups")) %>%
  full_join(ac3, by = c("q0002_hhid", "number_id", "ID_ECS", "grups"))
ach %>% 
  head()

cbind(ac1, ac2, ac3) %>% 
  head()
```

Las funciones de las librerías de la familia `tidyverse` tratan los nombres de las variables de un data frame de una manera distinta a como lo hacen las funciones de R base. Por ejemplo, admiten determinados nombres especiales, pero sin embargo no admiten variables distintas con el mismo nombre, como sí ocurre en el último ejemplo.

**Ejercicio:**

*Sustituír `cbind` por `bind_cols` en el último ejemplo. Qué ocurre si se sustituye el valor por defecto del argumento `.name_repair` por los otros valores posibles?*


## Rellenando datos

Cuando se combinan las filas mediante `bind_cols`, las columnas que sólo están en una base de datos se llenan con missings. Por ejemplo, es el caso de las variables sociodemográficas, que en el dataframe `acv` sólo tienen datos en las filas correspondientes a la ola 1, que son las filas obtenidas de `ac1`. 

```{r eval=TRUE}
acv %>%
  arrange(q0002_hhid) %>% # ordenamos por id
  head()
```


Acudimos ahora a la función `fill` de la librería `tidyr`:
```{r eval=TRUE}
library(tidyr)
acv %>%
  group_by(q0002_hhid) %>% # agrupamos por id y entonces
  arrange(wave) %>% # ordenamos por ola para tener la fila con datos antes que las otras, y entonces
  fill(sex, age, mar1, edu1) %>% # para cada id rellenamos las filas vacías de las variables especificadas con los valores que no son missings, y entonces
  ungroup() %>% # desagrupamos y entonces
  arrange(q0002_hhid) %>% # ordenamos por id para ver las mismas filas que arriba, y entonces
  head() # nos quedamos con las primeras filas
```


## Pivotar (vertical/largo --> horizontal/ancho)

- Bases de datos horizontales/anchas: aquellas con una fila para cada individuo y tantas columnas como observaciones por variable, por ejemplo el producto de un una fusión, como es el caso de `ach`
- Bases de datos verticales/largas (longitudinales): aquellas con tantas filas como observaciones se hayan hecho a todos los individuos y una columna por variable, por ejemplo el resultado de combinar filas, como es el caso de `acv`.

Pivotar es el proceso de transformar una base de datos vertical/longitudinal a una horizontal o a la inversa.

**Ejercicio:**

* *Modificar `acv` de tal manera que sus variables sociodemográficas estén completas tal como se indicó en la diapositiva anterior.*
* *Qué variables tiene acv?*
* *Qué variables de avc no tienen necesariamente los mismos valores en las distintas olas?*

```{r echo=FALSE, eval=TRUE}
acv <- acv %>%
  group_by(q0002_hhid) %>% # agrupamos por id y entonces
  arrange(wave) %>% # ordenamos por ola para tener la fila con datos antes que las otras, y entonces
  fill(sex, age, mar1, edu1) # para cada id rellenamos las filas vacías de las variables especificadas con los valores que no son missings
```

Pivotaje usando la función `pivot_wider` de la librería `tidyr`:


```{r eval=TRUE}
#?pivot_wider
acv %>%
  pivot_wider(names_from = c("wave"), values_from = c("hea", "dep")) %>%
  # select(-where(~all(is.na(.)))) %>% # quitamos aquellas columnas que cumplen que todos sus valores son missings
  head()

```


## Pivotar (horizontal/ancho --> vertical/largo)


Si tenemos un sólo conjunto de columnas longitudinal, por ejemplo `hea1`, `hea2` y `hea3`, podemos acudir a la función `pivot_longer` de la librería `tidyr`:

```{r eval=TRUE}
ach %>%
  select(-starts_with("dep")) %>% # quitamos las columnas que empiezan con dep y entonces
  pivot_longer(cols = starts_with("hea"), names_to = "wave", values_to = "hea") %>% # pivotamos, y entonces
  arrange(q0002_hhid) %>% head()
```

Cuando hay más de un conjunto de columnas que queremos pivotar, como en este caso, en el que tenemos por un lado `hea1`, `hea2` y `hea3` y por otro lado, `dep2` y `dep3`, usaremos la función `reshape` de R. Para ello, primero necesitamos el mismo número de columnas de `hea` y `dep`, por tanto creamos la columna `dep1`.

```{r, echo=TRUE, eval=TRUE}

ach$dep1 <- NA  # como en un data frame todas las variables tienen las mismas filas, R ya entiende que tiene que asignar NA para cada fila.

```

También necesitamos que el objeto sea un data frame propiamente dicho, en lugar de un tibble (son así llamados los data frames creados por las funciones de la familia `tidyverse`, que se caracterizan porque su clase es `c("tbl_df", "tbl", "data.frame")`)

```{r, echo=TRUE, eval=TRUE}

class(ach)
class(as.data.frame(ach))
reshape(as.data.frame(ach), varying = list(paste0("hea", 1:3), paste0("dep", 1:3)), v.names = c("hea", "dep"), timevar = "wave", idvar = "q0002_hhid", direction = "long") %>% 
  arrange(q0002_hhid) %>%
  head()

```



```{r eval=FALSE, echo=FALSE}
ach %>%
  pivot_longer(cols = c(starts_with("hea"), starts_with("dep")), names_to = c(".value", "wave"), names_pattern = "(.*)([0-9]$)") %>%
  arrange(q0002_hhid) %>% head()
```



## Correlación y tests de normalidad


- Cálculo de correlaciones

```{r eval=TRUE}
#cor(dataw1$score_sup, dataw1$income)
cor.test(dataw1$score_sup1, dataw1$income1)
```

**Ejercicio:**

*Consultar la ayuda de `cor`. Calcular la correlación de Spearman. Cómo tendríamos que hacer si hay valores missing?*


* Test de Shapiro-Wilk

```{r, echo=TRUE, eval=TRUE}

shapiro.test(dataw1$hea1)

```

* Test de Kolmogorov-Smirnov

```{r, echo=TRUE, eval=TRUE}

ks.test(dataw1$hea1, "pnorm")

```

* Ambos test son significativos, así pues descartamos la hipótesis nula consistente en la normalidad de la distribución de `hea1` para la muestra en `dataw1`.

* Para otros tests de normalidad como los de Lilliefors, Anderson-Darling o Jarque-Bera, disponemos de funciones en librerías como `DescTools`, `nortest` o `tseries`.




## Tests chi-cuadrado y de Fisher

```{r, eval = TRUE}
table(dataw1$mar_1, dataw1$sex)
```

- Test de chi (o ji o khi)-cuadrado de Pearson
    + Prueba no paramétrica que se utiliza para probar la independencia de dos variables categóricas nominales entre sí mediante la presentación de los datos en tablas de contingencia.
    + Hipótesis nula: independientes vs Hipotesis alternativa ($p\approx0$): dependientes
    + En la tabla de las frecuencias esperadas cada celda debe ser mayor o igual que 5 para poder aplicar este test

```{r, eval=TRUE}

test <- chisq.test(dataw1$mar_1, dataw1$sex)
test  # por defecto, test con correccion de continuidad si es 2x2
test$expected # frecuencia esperada de cada celda
chisq.test(dataw1$mar_1, dataw1$sex, correct = FALSE) # test sin corrección

```

- Test de Fisher

```{r, eval=TRUE}
fisher.test(dataw1$mar_1, dataw1$sex)
```


## Tests univariantes

```{r echo=FALSE, eval=TRUE}
set.seed(1)
```


- Test t de Student de comparación de una media muestral a la hipótesis nula 

```{r, eval=TRUE}
dataw1$new_var <- rnorm(nrow(dataw1))
mean(dataw1$new_var)

t.test(dataw1$new_var, mu = 0)
t.test(dataw1$new_var)$conf.int # intervalo de confianza para la media muestral de new_var en dataw1
```

- Test no paramétrico de los rangos con signo de Wilcoxon, de simetría de los datos respecto a la hipótesis nula

```{r, eval=TRUE}
mean(dataw1$hea1, na.rm = TRUE)
wilcox.test(dataw1$hea1, mu = 54, conf.int = TRUE, conf.level = 0.95, exact = FALSE)
```

Como conclusiones, no podemos descartar que la media de `new_var` sea 0, pero sí podemos descartar que los valores de `hea1` se localizen en torno a 54.


## Prueba t de Student (o t-test)

Comparamos entre grupos mediante un t-test:

```{r, eval=TRUE}
t.test(hea1 ~ sex, data = dataw1)
t.test(data$hea1, data$hea2, paired = TRUE) # comparamos el estado de salud en la ola 1 con la ola 2
t.test(hea1 ~ sex, data = dataw1, mu = -7) # comparamos la diferencia de medias con el valor mu (hipótesis nula)
```

**Nota:** *mediante el argumento `alternative` de la función `t.test`, podemos especificar si la hipótesis nula es la igualdad (test bilateral) o una desigualdad.*



## Prueba Wilcoxon-Mann-Whitney (también test U de Mann-Whitney o test de la suma de rangos de Wilcoxon)

* Prueba no paramétrica que compara los valores en dos grupos

```{r, echo=TRUE, eval=TRUE}

wilcox.test(hea1 ~ sex, data = dataw1, 
            alternative = "two.sided", mu = 0, 
            paired = FALSE, exact = FALSE, 
            conf.int = TRUE, conf.level = 0.95)

library(ggplot2)
```

Descartamos la hipótesis nula, por tanto podemos concluír que la distribución de `hea1` en los hombres es significativamente diferente de la distribución en las mujeres.

<div style="display: flex; align-items: center;">

<div>

```{r, eval=TRUE, fig.width=7, fig.height=3}


dataw1 %>% 
  filter(!is.na(hea1)) %>% 
  ggplot(aes(x = hea1)) + # asignamos la variable hea1 al eje x
  geom_histogram(bins = 15, fill = "turquoise", color = "black") + # creamos el histograma y lo personalizamos 
  facet_wrap(~sex) # dividimos la gráfica para las distintas categorías de sex

```

</div>

<div>

```{r, eval=TRUE, fig.width=7, fig.height=3}

dataw1 %>% 
  filter(!is.na(hea1)) %>% 
  ggplot(aes(x = sex, y = hea1)) +  # asignamos la variable sex al eje x y la variable hea1 al eje y
  geom_boxplot() + # creamos el boxplot
  coord_flip()

```


</div>

</div>


## ANOVA

-  Test de comparación de la distribución de una variable normal entre múltiples grupos

```{r, eval=TRUE, fig.height=4}

ks.test(dataw1$new_var, "pnorm")
dataw1 %>%
  filter(!is.na(edu1)) %>%
  ggplot(aes(x = edu1, y = new_var)) +
  geom_boxplot()

anovafit <- aov(new_var ~ edu1, data = dataw1)
summary(anovafit)
```


## Regresión lineal


<div style="display: flex; align-items: flex-start;">

<div>

```{r echo=FALSE, eval=TRUE}
dataw1 <- dataw1 %>% 
  mutate(across(c(sex, age, mar_1, edu1, phys_hea1, dep1, income_inf1), as.factor))
```


```{r eval=TRUE}
#?lm
fit <- lm(hea1 ~ age + sex + income1 + dep1, data = dataw1)
summary(fit)
coef(fit) # o fit$coefficients
#?confint
confint(fit, level = 0.95) # intervalos de confianza

```


</div>


<div>


```{r, eval=TRUE, fig.width=5, fig.height=4}

#predict
plot(fit)

```


</div>

</div>





## Regresión logística

<div style="display: flex; align-items: flex-start;">

<div>

```{r eval=TRUE}
#?glm
fit <- glm(dep1 ~ age + sex + income1*hea1 + mar_1*score_lon1, data = dataw1, family = binomial)
summary(fit)

# Coefficients as odds-ratios
exp(coef(fit))

```

</div>


<div>


```{r, eval=TRUE, fig.width=5, fig.height=4}

plot(fit)

```


</div>

</div>






## Gràficas de modelos lineales simples usando `ggplot`: una única variable predictora

```{r echo=TRUE, eval=TRUE, fig.height=5}


fit <- lm(hea1 ~ income1, data = dataw1)
dataw1 %>%
  filter(!is.na(hea1), !is.na(income1)) %>% # nos quedamos con las observaciones que no tienen missings en el modelo
  # filter(!if_any(c(hea1, income1), is.na)) %>% # lo mismo de forma resumida
  cbind(predict(fit, interval = "confidence")) %>% # añadimos la predicción del modelo y los intervalos de confianza como nuevas columnas
  ggplot(aes(x = income1)) + # creamos el cuadro y añadimos el eje x
  geom_point(aes(y = hea1)) + # añadimos los punos d la base de datos
  geom_line(aes(y = fit)) + # añadimos la línea que el modelo induce
  geom_ribbon(aes(ymin = lwr, ymax = upr), alpha = .15) + # añadimos los CI; también es posible como sigue
  # geom_line(aes(y = lwr), color = "red", linetype = "dashed") +
  # geom_line(aes(y = upr), color = "red", linetype = "dashed") +
  annotate("text", 
           label = paste("La correlación es", round(cor(dataw1$hea1, dataw1$income1, use = "complete.obs"), 2)),
           x = 30, y = 15) +
  theme_bw() # cambiamos el tema por defecto



```

## Gràficas de modelos lineales usando `ggplot`: una variable predictora continua y otra categórica

```{r echo=TRUE, eval=TRUE, fig.height=5}

library(ggplot2)
fit <- lm(hea1 ~ income1 + edu1, data = dataw1)
dataw1 %>%
  # filter(!is.na(hea1), !is.na(income1), !is.na(edu1)) %>% # nos quedamos con las observaciones que no tienen missings en el modelo
  filter(!if_any(c(hea1, income1, edu1), is.na)) %>% # lo mismo de forma resumida
  cbind(predict(fit, interval = "confidence")) %>% # añadimos la predicción del modelo y los intervalos de confianza como nuevas columnas
  ggplot(aes(x = income1, color = edu1)) + # creamos el cuadro y añadimos el eje x
  geom_point(aes(y = hea1)) + # añadimos los punos d la base de datos
  geom_line(aes(y = fit)) + # añadimos la línea que el modelo induce
  geom_ribbon(aes(ymin = lwr, ymax = upr, color = NULL, fill = edu1), alpha = .15) # añadimos los CI
  

```


## Gràficas de modelos lineales generalizados simples usando `ggplot`: una única variable predictora

```{r echo=TRUE, eval=TRUE, fig.height=5}

library(ggplot2)
fit <- glm(dep1 ~ income1, data = dataw1, family = binomial)
dataw1 %>%
  filter(!if_any(c(dep1, income1), is.na)) %>%  # nos quedamos con las observaciones que no tienen missings en el modelo
  mutate(fit = predict(fit, type = "response")) %>% # añadimos la predicción del modelo como nuevas columnas
  ggplot(aes(x = income1)) + # creamos el cuadro y añadimos el eje x
  geom_line(aes(y = fit)) + # añadimos la línea que el modelo induce
  labs(y = "Predicted probability of dep1 == Yes", 
       title = "Predicting  depression from income through a logistic model",
       caption = "Data source: A cohort study") + # especificamos la etiqueta del eje y, del título y de pie de figura
  theme_classic() #cambiamos el tema por defecto



```


```{r echo=FALSE, eval=FALSE, fig.height=5}

library(ggplot2)
fit <- glm(dep1 ~ income1, data = dataw1, family = binomial)
dataw1 %>%
  filter(!if_any(c(dep1, income1), is.na)) %>%  # nos quedamos con las observaciones que no tienen missings en el modelo
  mutate(fit = predict(fit, type = "response")) %>% # añadimos la predicción del modelo como nuevas columnas
  # cbind(predict(fit, type = "link", se.fit = TRUE)) %>% # añadimos la predicción del modelo como nuevas columnas
  # mutate(lwr = fit - 1.96 * se.fit, upr = fit + 1.96 * se.fit) %>%
  # mutate(across(c(fit, lwr, upr), ~1/(1+exp(-.)))) %>%
  ggplot(aes(x = income1)) + # creamos el cuadro y añadimos el eje x
  geom_line(aes(y = fit)) + # añadimos la línea que el modelo induce
  # geom_ribbon(aes(ymin = lwr, ymax = upr), alpha = .15) + # añadimos los CI
  labs(y = "Predicted probability of dep1 == Yes") + # especificamos la etiqueta del eje y
  theme_classic() #cambiamos el tema por defecto



```


## Gràficas de modelos lineales generalizados usando `ggplot`: una variable predictora continua y otra categórica

```{r echo=TRUE, eval=TRUE, fig.height=5}

library(ggplot2)
fit <- glm(dep1 ~ income1 + edu1, data = dataw1, family = binomial)
dataw1 %>%
  filter(!if_any(c(dep1, income1, edu1), is.na)) %>%  # nos quedamos con las observaciones que no tienen missings en el modelo
  mutate(fit = predict(fit, type = "response")) %>% # añadimos la predicción del modelo como nuevas columnas
  ggplot(aes(x = income1, color = edu1)) + # creamos el cuadro y añadimos el eje x
  geom_line(aes(y = fit)) + # añadimos la línea que el modelo induce
  labs(y = "Predicted probability of dep1 == Yes") + # especificamos la etiqueta del eje y
  theme_minimal() # cambiamos el tema por defecto



```

```{r echo=FALSE, eval=FALSE}

library(ggplot2)
fit <- glm(dep1 ~ income1 * edu1, data = dataw1, family = binomial)
dataw1 %>%
  filter(!if_any(c(dep1, income1, edu1), is.na)) %>%  # nos quedamos con las observaciones que no tienen missings en el modelo
  # mutate(fit = predict(fit, type = "response")) %>% # añadimos la predicción del modelo como nuevas columnas
  cbind(predict(fit, type = "link", se.fit = TRUE)) %>% # añadimos la predicción del modelo como nuevas columnas
  mutate(lwr = fit - 1.96 * se.fit, upr = fit + 1.96 * se.fit) %>%
  mutate(across(c(fit, lwr, upr), ~1/(1+exp(-.)))) %>%
  ggplot(aes(x = income1, color = edu1)) + # creamos el cuadro y añadimos el eje x
  geom_line(aes(y = fit)) + # añadimos la línea que el modelo induce
  geom_ribbon(aes(ymin = lwr, ymax = upr, fill = edu1), alpha = .15) + # añadimos los CI
  labs(y = "Predicted probability of dep1 == Yes") +  # especificamos la etiqueta del eje y
  theme_bw() # cambiamos el tema por defecto



```

## Otras formas de obtener resultados estadísticos en R

De la misma manera que `tidyverse` hace referencia a una colección de librerías que simplifican la manipulación de datframes, existe otra colección de librerías, `easystats` (https://easystats.github.io/easystats/), cuyo objetivo es mostrar los resultados de tests y modelos estadísticos con mejor formato.

**Ejercicio:**

*Instalar y cargar las librerías `performance` y `parameters` y probar las funciones `model_performance` y `model_parameters` aplicadas a `fit`*.

La librería `modelsummary` dispone de 2 <u>funciones</u> que permiten visualizar multiples resultados en tablas bien organizadas: 

+ `modelsummary` (https://vincentarelbundock.github.io/modelsummary/articles/modelsummary.html) y 
+ `datasummary` (https://vincentarelbundock.github.io/modelsummary/articles/datasummary.html). 

Otras <u>librerías</u> que permiten visualizar descriptivos y resultados resumidos en tablas son:

+ `summarytools` (https://cran.r-project.org/web/packages/summarytools/vignettes/introduction.html) y 
+ `compareGroups` (https://cran.r-project.org/web/packages/compareGroups/vignettes/compareGroups_vignette.html).

Existen distintas <u>librerías</u> que facilitan la representación gráfica de modelos, predicciones, ...:

+ `jtools` (https://cran.r-project.org/web/packages/jtools/vignettes/effect_plot.html)
+ `effects` (https://cran.r-project.org/web/packages/effects/vignettes/predictor-effects-gallery.pdf)
+ `ggeffects`(https://strengejacke.github.io/ggeffects/)




## Otras funciones y librerías útiles en R

* A veces conviene guardar el nombre de un objeto en una variable y trabajar con la misma.

```{r, echo=TRUE, eval=TRUE}

x <- 4       # asignamos el nombre x al objeto 4
w <- "x"     # guardamos el nombre x en la variable w
x
w
get(w)       # con la función get recuperamos el objeto asignado al nombre (x) guardado en la variable w
assign(w,5)  # asignamos el valor 5 al caracter guardado en w (x)
get(w)

```

* Si queremos ejecutar el código en R guardado en un archivo (habitualmente con la extensión `.r`), se puede ejecutar a través de la función `source`. Por ejemplo `source("fichero.r")`.
* En ocasiones nos puede interesar el número de caracteres en una cadena. Lo podemos obtener mediante la función `nchar`.

```{r, echo=TRUE, eval=TRUE}
nchar(paste(x, 4)) == 3
```

* Tal como la librería `haven` guarda las etiquetas de los objetos como atributos de los mismos, a los que se puede acceder por medio de la función `attributes` otras librerías como `labelled`, `sjmisc` o `sjlabelled` también tienen múltiples funciones creadas para trabajar con etiquetas.

* La función de R `sample` permite seleccionar elementos de un vector aleatoriamente. La función `slice_sample` de la librería `dplyr` permite seleccionar filas (observaciones) al azar de un data frame.

* La función `ggsave` permite guardar gráficas generadas a partir de `ggplot`, especificando el formato, medida y calidad entre otros.



## Apéndice

* **Ojo**: 
    + Hay una cantidad enorme de librerías, muchas de las cuales comparten funciones (porque unas llaman a otras), pero también muchas de las cuales comparten nombres de funciones que son distintas (como muestra la advertencia al cargar la librería con funciones que ya están en el entorno).  Por ejemplo:
    + Las librerías `plyr` y `dplyr` comparten varias funciones, entre ellas `rename`. Si se carga primero `dplyr` y después `plyr` R asocia `rename` a la función de `plyr`, pero al usarla como la función de `dplyr`, es probable que se produzca un error.
    + Es de los más frecuentes y extraños, por ello hay varias maneras de solucionarlo. Esencialmente, mediante el operador `::`

```{r, echo=TRUE, eval=TRUE, include=FALSE}

lapply(paste('package:', names(sessionInfo()$otherPkgs), sep = ""), detach, character.only = TRUE, unload = TRUE)
```


```{r, echo=TRUE, eval=TRUE, error=TRUE}

library(dplyr); library(plyr)
# ?rename # con la ayuda podemos ver que esta función está en varias librerías actualmente cargadas
names(ac1)
names(rename(ac1, hea = hea1)) # error
names(dplyr::rename(ac1, hea = hea1)) # especificamos que la función que queremos es la de dplyr
names(plyr::rename(ac1, hea = hea1)) # comprobamos que la función que estaba usando antes era la de plyr, ya que genera el mismo error
rename <- dplyr::rename # otra solución es asignar al nombre la función de dplyr
names(rename(ac1, hea = hea1)) # ya no hay error

```

```{r, echo=FALSE, eval=FALSE}
detach("package:plyr", unload=TRUE)
detach("package:dplyr", unload=TRUE)

```


## 

<img src="RTAF.png" width="1116px" height="900px" style="display: block; margin-left: auto; margin-right: auto;">

## Algunos recursos

Tutoriales introductorios a R:

* http://rosuda.org/mitarbeiter/pilhoefer/rkurs2.pdf
* http://b2slab.upc.edu/software-and-tutorials/r-nutshell/
* https://www.cyclismo.org/tutorial/R/index.html
* https://www.uv.es/vcoll/preliminares.html
* http://people.math.aau.dk/~sorenh/misc/rdocs/Rintro-notes.pdf
* https://cran.r-project.org/doc/contrib/Verzani-SimpleR.pdf
* en la pestaña Resources de la web de [RStudio](https://rstudio.com/)

Blogs:

+ https://statisticsglobe.com/r-programming-language/
+ enfocados a la estadística, pero no sólo (de hecho, diría que los siguientes son los mejores): 
    * http://www.sthda.com/english/
    * http://www.flutterbys.com.au/stats/course.html
    * [http://www.r-tutor.com/](http://www.r-tutor.com/sitemap) (incluye contenido de estadística bayesiana y machine learning, por otra parte un poco anticuado)
+ enfocado a la investigación en psicología (y vinculado a la librería `psych`):
    * [http://personality-project.org/r/](http://personality-project.org/r/)
+ https://www.statmethods.net/index.html

Multitud de libros:

+ https://bookdown.org/
+ https://www.bigbookofr.com/ (contenidos parecidos a los del link anterior, en menor cantidad, aunque clasificados por materias)

Cursos online (MOOC's) en plataformas como Coursera, edX, etc.

## Más recursos

Acerca de librerías o materias específicas:

+ sobre librerías en general:
    * https://rdrr.io/
    * https://cran.r-project.org/web/views/
+ gráficas en general:
    * https://www.r-graph-gallery.com/
    * https://r-charts.com
    * https://ggplot2-book.org, el libro de `ggplot2`
    * https://exts.ggplot2.tidyverse.org/gallery/, librerías que extienden las funcionalidades de `ggplot2`
+ formas de mostrar descriptivos:
    * https://dabblingwithdata.wordpress.com/2018/01/02/my-favourite-r-package-for-summarising-data/
+ meta-análisis:
    * https://bookdown.org/MathiasHarrer/Doing_Meta_Analysis_in_R/
+ neuroimagen:
    * https://www.alexejgossmann.com/MRI_viz/
    * https://johnmuschelli.com/
    * https://openwetware.org/wiki/RAVE




Recursos de RStudio

+ El foro https://community.rstudio.com/ principalmente centrado (aunque no exclusivamente) en cuestiones relacionadas con RStudio y con las librerías de la familia tidyverse
+ La página web https://support.rstudio.com/hc/en-us contiene material acerca de RStudio
+ El blog https://blog.rstudio.com publica contenido diverso relacionado con los productos de la compañía RStudio
+ El blog https://rviews.rstudio.com está más enfocado al usuario de R, aportando información y ejemplos del uso de distintas librerías, así como acerca de conferencias de usuarios de R
+ El blog https://www.tidyverse.org/blog/ publica habitualmente entradas acerca de las nuevas librerías de la familia `tidyverse` o de actualizaciones relevantes
    
Podéis consultarme vustras dudas a través de mi dirección de email: iago.gine@sjd.es